const fs = require('fs');

const args = process.argv.slice(2);

const flags = args.filter(i => i.startsWith('-'));
const [inputPath, outputPath] = args;

if (!inputPath || !outputPath) {
    console.error('Usage: npx compile <input> <output> [flags]');
    process.exit(1);
}

if (!fs.existsSync(inputPath)) {
    console.error(`Input file ${inputPath} does not exist.`);
    process.exit(1);
}

if (fs.existsSync(outputPath) && !(flags.includes('-f') || flags.includes('--force'))) {
    console.error(`Output file ${outputPath} already exists. Use -f or --force to overwrite.`);
    process.exit(1);
}

const prebakedComponentDefinitionMap = {
    br: () => '<br />',
    div: ({ children, className }) => `<div className="${className}">{${children}}</div>`,
    image: ({ values, className }) => `<img className="${className}" src="${values?.[0]}" />`,
    url: ({ values, className }) => `<a href="${values?.[0]}" className="${className}">${values?.[1]}</a>`,
    vspace: ({ values }) => `<div style={{ height: ${values?.[0]} }} />`,
    hspace: ({ values }) => `<div style={{ width: ${values?.[0]} }} />`,
};

const input = fs.readFileSync(inputPath, 'utf8');
const parsed = parse(input);
const html = toHtml(parsed);
const requiredComponentImports = extractRequiredComponentImports(html);

fs.writeFileSync(outputPath, generateFile(html, requiredComponentImports));

function generateFile(html, requiredComponentImports) {
    return [
        '// This file was generated by @wuguishifu/page-parser.',
        '// Feel free to remove these comments and to directly modify this file as you wish.',
        '',
        ...requiredComponentImports.map(i => `import ${i} from '@/components/${i}';`),
        '',
        'export default function Page() {',
        '  return (',
        html.split('\n').map(i => '    ' + i).join('\n'),
        '  );',
        '};'
    ].join('\n');
}

function parse(text) {
    const queue = text
        .replace(/\r\n|\n/g, '\n')
        .replace(/ {2,}/g, '')
        .split(/\\/g)
        .filter(i => i)
        .map(i => ('\\' + i).trim())
        .flatMap(i => i.split(/\n\n/g))
        .map(i => i.replace(/\n/g, ' '))
        .flatMap(i => i.split(/(\\.*?(?:{.*?}){1,}(?:\[.*?\]){0,})/gm))
        .map(i => i.trim())
        .filter(i => i)
    return queue;
}

function toHtml(tokens) {
    let depth = 1;
    let html = '';

    html += `${' '.repeat(2 * depth - 2)}<>`;

    for (const token of tokens) {
        if (token.startsWith('\\end')) depth--;
        html += `\n${' '.repeat(2 * depth)}${tokenToTag(token)}`;
        if (token.startsWith('\\begin')) depth++;
    }

    html += `\n${' '.repeat(2 * depth - 2)}</>`;

    return html;
}

function tokenToTag(token) {
    switch (true) {
        case token.startsWith('\\begin'): {
            const [name, ...values] = token.match(/\{.*?\}/g)?.map(i => i.substring(1, i.length - 1)) ?? [];
            const className = token.match(/\[(.*)\]/);

            const valueMap = values.map(i => {
                const [key, value] = i.split('=');
                return `${key}="${value}"`;
            });

            return `<${name}${className ? ` className="${className[1]}"` : ''}${valueMap.length ? ' ' + valueMap.join(' ') : ''}>`
        }

        case token.startsWith('\\end'): {
            const [name] = token.match(/\{.*?\}/g)?.map(i => i.substring(1, i.length - 1)) ?? [];
            return `</${name}>`
        }

        case token.startsWith('\\'): {
            const name = token.match(/\\(.*?)\{/);
            const values = token.match(/\{.*?\}/g)?.map(i => i.substring(1, i.length - 1));
            const className = token.match(/\[(.*)\]/);
            return prebaked({
                name: name ? name[1] : 'div',
                values: values ?? undefined,
                className: className ? className[1] : undefined
            });
        }

        default: {
            const formatted = token
                .replaceAll('_ _', '')
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.*?)\*/g, '<em>$1</em>')
                .replace(/__(.*?)__/g, '<u>$1</u>');

            return `<p dangerouslySetInnerHTML={{ __html: \`${formatted}\` }} />`;
        }
    }
}

function prebaked(token) {
    if (token.name in prebakedComponentDefinitionMap) {
        return prebakedComponentDefinitionMap[token.name](token);
    }
}

function extractRequiredComponentImports(html) {
    const regex = /<([a-zA-Z0-9]+).*?>/g;
    const matches = [...html.matchAll(regex)];
    const set = new Set();
    for (const match of matches) {
        if (match[1].toLowerCase() === match[1]) continue;
        set.add(match[1]);
    }
    return [...set];
}